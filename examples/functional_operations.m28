# Functional Operations with Lists and Tuples

# This example demonstrates the functional operations added to M28
# All list operations now return new lists instead of modifying the original

# --------------------------
# List Operations
# --------------------------

(print "=== List Operations ===")

# Create a list
(= numbers (list 1 2 3 4 5))
(print "Original list:" numbers)

# Functional append - returns a new list without modifying the original
(= numbers2 (numbers.append 6))
(print "After append:" numbers2)
(print "Original list (unchanged):" numbers)

# Functional map - apply a function to each element
(= doubled (numbers.map (lambda (x) (* x 2))))
(print "Doubled list:" doubled)
(print "Original list (unchanged):" numbers)

# Functional filter - keep elements matching a predicate
(= evens (numbers.filter (lambda (x) (== (% x 2) 0))))
(print "Even numbers:" evens)
(print "Original list (unchanged):" numbers)

# Functional reduce - combine elements into a single value
(= sum (numbers.reduce +))
(print "Sum of numbers:" sum)

# Example with initial value
(= sum_with_init (numbers.reduce + 10))
(print "Sum with initial value 10:" sum_with_init)

# Take and drop
(= first_three (numbers.take 3))
(print "First three elements:" first_three)
(= last_two (numbers.drop 3))
(print "Elements after dropping first three:" last_two)

# Slice
(= middle (numbers.slice 1 4))
(print "Slice from index 1 to 4:" middle)

# Concat
(= combined (numbers.concat (list 6 7 8)))
(print "Concatenated list:" combined)

# Reverse
(= reversed (numbers.reverse))
(print "Reversed list:" reversed)

# Chaining operations
(= result (numbers.filter (lambda (x) (> x 2))
                 .map (lambda (x) (* x 3))
                 .take 2))
(print "Chained operations result:" result)

# --------------------------
# Tuple Operations
# --------------------------

(print "\n=== Tuple Operations ===")

# Create a tuple
(= t1 (1, 2, 3, 4, 5))
(print "Original tuple:" t1)

# Map
(= t2 (t1.map (lambda (x) (* x 2))))
(print "Mapped tuple:" t2)

# Filter
(= t3 (t1.filter (lambda (x) (> x 2))))
(print "Filtered tuple:" t3)

# Concatenate tuples
(= t4 (t1.concat (6, 7, 8)))
(print "Concatenated tuple:" t4) 

# Tuple slice
(= t5 (t1.slice 1 4))
(print "Sliced tuple:" t5)

# Take and drop
(= t6 (t1.take 2))
(print "Take first 2 elements:" t6)
(= t7 (t1.drop 3))
(print "Drop first 3 elements:" t7)

# Reduce
(= t8 (t1.reduce +))
(print "Sum of tuple elements:" t8)

# Reverse
(= t9 (t1.reverse))
(print "Reversed tuple:" t9)

# Tuple immutability test
(try
  (= t1.0 99)  # This should fail as tuples are immutable
  (print "FAILED: Tuple was modified")
  (except Exception e
    (print "SUCCESS: Tuples are immutable, as expected")))