# Quicksort implementation in M28
# This demonstrates a classic divide-and-conquer sorting algorithm

# Quicksort with a simpler approach
(def (quicksort lst)
  # Base case: empty or single-element list
  (if (< (len lst) 2)
    lst
    (begin
      # Choose first element as pivot
      (= pivot (nth lst 0))
      
      # Create lists for elements less than, equal to, and greater than pivot
      (= less [])
      (= equal [])
      (= greater [])
      
      # Partition the elements
      (= i 0)
      (while (< i (len lst))
        (= current (nth lst i))
        (if (< current pivot)
          (= less (+ less [current]))
          (if (== current pivot)
            (= equal (+ equal [current]))
            (= greater (+ greater [current]))))
        (= i (+ i 1)))
      
      # Recursively sort and combine
      (+ (quicksort less) equal (quicksort greater)))))

# Test the quicksort function
(= numbers [5 2 9 1 7 6 3])
(print "Original list:")
(print numbers)
(print "Sorted list:")
(print (quicksort numbers))

# Test with other examples
(= numbers2 [42 13 7 1 100 56 24 37 21])
(print "\nSorting another list:")
(print "Original:" numbers2)
(print "Sorted:" (quicksort numbers2))

# Test with duplicates
(= dup_list [3 1 4 1 5 9 2 6 5 3 5])
(print "\nSorting list with duplicates:")
(print "Original:" dup_list)
(print "Sorted:" (quicksort dup_list))

# Test with edge cases
(print "\nEdge cases:")
(print "Empty list:" (quicksort []))
(print "Single element:" (quicksort [42]))
(print "Already sorted:" (quicksort [1 2 3 4 5]))
(print "Reverse sorted:" (quicksort [5 4 3 2 1]))