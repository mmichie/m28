# Quicksort implementation in M28
# We'll use a simplified selection sort algorithm since 
# there seems to be an issue with the more complex implementations

# Selection sort - finds the minimum element and puts it at the beginning
(def (selection-sort lst)
  (if (< (len lst) 2)
    lst
    (begin
      (= result [])
      (= work-list (+ lst []))  # Clone the list
      
      # Loop until work-list is empty
      (while (> (len work-list) 0)
        # Find minimum element
        (= min-val (nth work-list 0))
        (= min-idx 0)
        (= i 1)
        
        (while (< i (len work-list))
          (if (< (nth work-list i) min-val)
            (begin
              (= min-val (nth work-list i))
              (= min-idx i)))
          (= i (+ i 1)))
        
        # Add minimum to result and remove from work-list
        (= result (+ result [min-val]))
        (= work-list (+ (slice work-list 0 min-idx) (slice work-list (+ min-idx 1))))
      )
      
      result)))

# Test the sort function
(= numbers [5 2 9 1 7 6 3])
(print "Original list:")
(print numbers)
(print "Sorted list:")
(print (selection-sort numbers))

# Test with other examples
(= numbers2 [42 13 7 1 100 56 24 37 21])
(print "\nSorting another list:")
(print "Original:" numbers2)
(print "Sorted:" (selection-sort numbers2))

# Test with duplicates
(= dup_list [3 1 4 1 5 9 2 6 5 3 5])
(print "\nSorting list with duplicates:")
(print "Original:" dup_list)
(print "Sorted:" (selection-sort dup_list))

# Test with edge cases
(print "\nEdge cases:")
(print "Empty list:" (selection-sort []))
(print "Single element:" (selection-sort [42]))
(print "Already sorted:" (selection-sort [1 2 3 4 5]))
(print "Reverse sorted:" (selection-sort [5 4 3 2 1]))