# 03_advanced_closures.m28
# Advanced Closure Patterns and Techniques

###############################################################################
# ADVANCED CLOSURE CONCEPTS
###############################################################################
# This file demonstrates more sophisticated closure patterns including:
# 1. Nested closures (closures within closures)
# 2. Closures with multiple methods
# 3. Factory patterns that generate specialized closures
# 4. Object-like patterns with private state
#
# These patterns demonstrate how closures can be used to implement
# powerful data encapsulation and object-oriented programming concepts.

###############################################################################
# PERSON FACTORY WITH MULTIPLE METHODS
###############################################################################

# Create a person with multiple methods that all share the same private state
(def (make-person name age)
  # Private person state (encapsulated within the closure)
  (= birthdays 0)
  (= friends [])
  
  # Create a dictionary of methods, each sharing access to the private state
  (dict
    # Method to have a birthday
    "birthday" (lambda ()
                (= birthdays (+ birthdays 1))
                (= age (+ age 1))
                (+ name " is now " (str age) " years old!"))
    
    # Method to add a friend
    "add-friend" (lambda (friend)
                  (= friends (+ friends [friend]))
                  (+ name " is now friends with " friend "!"))
    
    # Method to list all friends
    "friends" (lambda ()
              (if (== (len friends) 0)
                (+ name " has no friends yet.")
                (+ name "'s friends: " (str friends))))
    
    # Method to get person info
    "info" (lambda ()
            (dict 
              "name" name 
              "age" age 
              "birthdays" birthdays 
              "friends_count" (len friends)))))

# Create a few people
(= alice (make-person "Alice" 30))
(= bob (make-person "Bob" 25))

# Test methods
(print "Person Example:")
(print "Initial info:")
(print "Alice: " ((get alice "info")))
(print "Bob: " ((get bob "info")))

# Have some birthdays
(print ((get alice "birthday")))
(print ((get bob "birthday")))

# Add some friends
(print ((get alice "add-friend") "Bob"))
(print ((get bob "add-friend") "Alice"))
(print ((get bob "add-friend") "Charlie"))

# List friends
(print ((get alice "friends")))
(print ((get bob "friends")))

# Check updated info
(print "Updated info:")
(print "Alice: " ((get alice "info")))
(print "Bob: " ((get bob "info")))

###############################################################################
# NESTED CLOSURE: PERSON FACTORY FACTORY
###############################################################################

# A factory that creates person factories with specialized behaviors
(def (create-person-factory default-age)
  # Factory-level private state
  (= people-created 0)
  
  # Return a function that creates people with the default age
  (lambda (name)
    # Increment the factory counter
    (= people-created (+ people-created 1))
    
    # Person-level private state
    (= age default-age)
    (= friends [])
    
    # Return a dictionary of methods
    (dict
      # Get person's info
      "info" (lambda ()
              (dict
                "name" name
                "age" age
                "id" people-created
                "friend_count" (len friends)))
      
      # Add a friend
      "add-friend" (lambda (friend)
                    (= friends (+ friends [friend]))
                    (+ name " is now friends with " friend))
      
      # Get factory stats
      "factory-stats" (lambda ()
                      (+ "This factory has created " (str people-created) " people")))))

# Create factories for different age groups
(print "\nNested Closure Example:")
(= child-factory (create-person-factory 10))
(= adult-factory (create-person-factory 30))

# Create people from both factories
(= emma (child-factory "Emma"))
(= jack (child-factory "Jack"))
(= michael (adult-factory "Michael"))

# Test the people
(print "Child 1 info: " ((get emma "info")))
(print "Child 2 info: " ((get jack "info")))
(print "Adult info: " ((get michael "info")))

# Add friends
(print ((get emma "add-friend") "Jack"))
(print ((get michael "add-friend") "Emma"))

# Check factory stats (notice each factory has its own count)
(print ((get emma "factory-stats")))  # Should show 2 people created
(print ((get michael "factory-stats")))  # Should show 1 person created

###############################################################################
# ADVANCED OBJECT SYSTEM WITH METHOD DISPATCH
###############################################################################

# A more complex object system with method dispatch
(def (create-object initial-attrs)
  # Private object state
  (= attributes initial-attrs)
  (= methods (dict))
  
  # Method to access attributes
  (def (get-attr name)
    (get attributes name))
  
  # Method to set attributes
  (def (set-attr name value)
    (= attributes (dict-set attributes name value))
    value)
  
  # Method to add a new method
  (def (add-method name fn)
    (= methods (dict-set methods name fn))
    name)
  
  # Method dispatcher
  (def (dispatch method-name . args)
    (= method (get methods method-name))
    (if method
        (apply method args)
        (print "Unknown method: " method-name)))
  
  # Add standard methods
  (add-method "get" get-attr)
  (add-method "set" set-attr)
  (add-method "add-method" add-method)
  
  # Return the dispatcher function
  dispatch)

# Create a bank account object
(print "\nAdvanced Object System:")
(= account (create-object (dict "balance" 1000 "owner" "John Doe")))

# Add custom methods to the account
(account "add-method" "deposit" 
  (lambda (amount)
    (= current-balance (account "get" "balance"))
    (= new-balance (+ current-balance amount))
    (account "set" "balance" new-balance)
    (+ "Deposited " (str amount) ". New balance: " (str new-balance))))

(account "add-method" "withdraw" 
  (lambda (amount)
    (= current-balance (account "get" "balance"))
    (if (>= current-balance amount)
        (do
          (= new-balance (- current-balance amount))
          (account "set" "balance" new-balance)
          (+ "Withdrew " (str amount) ". New balance: " (str new-balance)))
        "Insufficient funds")))

# Test the account
(print "Account owner: " (account "get" "owner"))
(print "Initial balance: " (account "get" "balance"))
(print (account "deposit" 500))
(print (account "withdraw" 200))
(print (account "withdraw" 2000))  # Should fail
(print "Final balance: " (account "get" "balance"))

###############################################################################
# MEMOIZATION WITH CLOSURES
###############################################################################

# Function that creates a memoized version of any function
(def (memoize fn)
  # Private cache to store results
  (= cache (dict))
  
  # Return a function that uses the cache
  (lambda (x)
    # Check if we've already computed this value
    (if (dict-contains? cache x)
        (do
          #(print "Cache hit for " x)
          (get cache x))
        (do
          #(print "Cache miss for " x)
          (= result (fn x))
          (= cache (dict-set cache x result))
          result))))

# Define a "slow" function that we want to memoize
(def (slow-fibonacci n)
  #(print "Computing fibonacci(" n ")")
  (if (< n 2)
      n
      (+ (slow-fibonacci (- n 1)) 
         (slow-fibonacci (- n 2)))))

# Create a memoized version
(print "\nMemoization Example:")
(= fast-fibonacci (memoize slow-fibonacci))

# First call will be slow
(print "First call to fast-fibonacci(10):")
(= start-time (time))
(= result1 (fast-fibonacci 10))
(= end-time (time))
(print "Result: " result1)
(print "Time taken: " (- end-time start-time) " seconds")

# Second call should be faster (cached)
(print "Second call to fast-fibonacci(10):")
(= start-time (time))
(= result2 (fast-fibonacci 10))
(= end-time (time))
(print "Result: " result2)
(print "Time taken: " (- end-time start-time) " seconds")