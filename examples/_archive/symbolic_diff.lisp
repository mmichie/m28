; Define a function to differentiate a symbolic expression
(defun diff (expr var)
  (cond
    ((numberp expr) 0)
    ((eq expr var) 1)
    ((symbolp expr) 0)
    ((eq (car expr) '+) (list '+ (diff (cadr expr) var) (diff (caddr expr) var)))
    ((eq (car expr) '-) (list '- (diff (cadr expr) var) (diff (caddr expr) var)))
    ((eq (car expr) '*) (list '+ (list '* (cadr expr) (diff (caddr expr) var))
                                (list '* (diff (cadr expr) var) (caddr expr))))
    ((eq (car expr) '/) (list '/ (list '- (list '* (diff (cadr expr) var) (caddr expr))
                                        (list '* (cadr expr) (diff (caddr expr) var)))
                               (list '* (caddr expr) (caddr expr))))
    ((eq (car expr) 'expt) (let ((base (cadr expr)) (exp (caddr expr)))
                             (if (numberp exp)
                                 (list '* exp (list 'expt base (list '- exp 1)) (diff base var))
                                 (error "Exponent must be a number"))))
    (t (error "Unknown expression type -- DIFF" expr))))

; Simplify the symbolic expression
(defun simplify (expr)
  (cond
    ((atom expr) expr)
    ((eq (car expr) '+)
     (let ((simplified (map 'list #'simplify (cdr expr))))
       (if (every #'numberp simplified)
           (apply #'+ simplified)
           (cons '+ simplified))))
    ((eq (car expr) '-)
     (let ((simplified (map 'list #'simplify (cdr expr))))
       (if (every #'numberp simplified)
           (apply #'- simplified)
           (cons '- simplified))))
    ((eq (car expr) '*)
     (let ((simplified (map 'list #'simplify (cdr expr))))
       (if (every #'numberp simplified)
           (apply #'* simplified)
           (cons '* simplified))))
    ((eq (car expr) '/)
     (let ((simplified (map 'list #'simplify (cdr expr))))
       (if (every #'numberp simplified)
           (apply #'/ simplified)
           (cons '/ simplified))))
    (t expr)))

; Helper function to check if all elements satisfy a predicate
(defun every (pred lst)
  (cond
    ((null lst) t)
    ((funcall pred (car lst)) (every pred (cdr lst)))
    (t nil)))

; Custom print function
(defun custom-print (expr)
  (cond
    ((null expr) (princ "nil"))
    ((numberp expr) (princ expr))
    ((symbolp expr) (princ expr))
    ((atom expr) (princ expr))
    (t (princ "(")
       (custom-print (car expr))
       (do ((rest (cdr expr) (cdr rest)))
           ((null rest))
         (princ " ")
         (custom-print (car rest)))
       (princ ")"))))

; Test cases
(defun test-diff ()
  (let ((expr1 '(+ (* 2 x) (* 3 (expt x 2))))
        (expr2 '(/ (* 3 (expt x 2)) (* 2 x)))
        (expr3 '(- (expt x 3) (* 2 (expt x 2)))))
    (princ "Expression 1: ")
    (custom-print expr1)
    (princ "\nDifferentiated: ")
    (custom-print (simplify (diff expr1 'x)))
    (princ "\nExpression 2: ")
    (custom-print expr2)
    (princ "\nDifferentiated: ")
    (custom-print (simplify (diff expr2 'x)))
    (princ "\nExpression 3: ")
    (custom-print expr3)
    (princ "\nDifferentiated: ")
    (custom-print (simplify (diff expr3 'x)))
    (princ "\n")))

; Run the test cases
(test-diff)
