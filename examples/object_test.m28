# Object system test
# Tests if object-like behavior works correctly with closures

# A counter with get/increment/decrement operations
(def (make-counter)
  # Private state
  (= count 0)
  
  # Return a dispatch function
  (lambda (op)
    (if (== op "get")
      count
      (if (== op "inc")
        (begin
          (= count (+ count 1))
          count)
        (if (== op "dec")
          (begin
            (= count (- count 1))
            count)
          "unknown")))))

# Create two counters
(= c1 (make-counter))
(= c2 (make-counter))

# Test operations
(print "Counter 1 initial: " (c1 "get"))
(print "Counter 1 increment: " (c1 "inc"))
(print "Counter 1 increment again: " (c1 "inc"))
(print "Counter 1 current: " (c1 "get"))

(print "Counter 2 initial: " (c2 "get"))
(print "Counter 2 increment: " (c2 "inc"))
(print "Counter 2 decrement: " (c2 "dec"))
(print "Counter 2 current: " (c2 "get"))

# Verify counter 1 still has its own state
(print "Counter 1 unchanged: " (c1 "get"))

# A person with name/age/birthday operations
(def (make-person name age)
  # Return a dispatch function
  (lambda (op)
    (if (== op "name")
      name
      (if (== op "age")
        age
        (if (== op "birthday")
          (begin
            (= age (+ age 1))
            (+ name " is now " (str age) " years old!"))
          "unknown")))))

# Create people
(= alice (make-person "Alice" 30))
(= bob (make-person "Bob" 25))

# Test operations
(print "Alice's name: " (alice "name"))
(print "Alice's age: " (alice "age"))
(print "Bob's name: " (bob "name"))
(print "Bob's age: " (bob "age"))

# Test birthdays
(print (alice "birthday"))
(print (alice "birthday"))
(print "Alice's age after birthdays: " (alice "age"))

# Test bob's birthday separately
(print (bob "birthday"))
(print "Bob's age after birthday: " (bob "age"))