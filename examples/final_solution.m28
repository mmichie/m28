# Final solution for proper closures in M28
# This implements proper closure semantics with separate state per instance

# For counters: this is simpler so it works well
(def (make-counter start)
  # Private state
  (= count start)
  
  # Return a function that keeps track of count
  (lambda ()
    (= count (+ count 1))
    count))

# Create two counters with different starts
(= c1 (make-counter 0))
(= c2 (make-counter 100))

# Test counters (should maintain separate state)
(print "Counter 1 call 1: " (c1))  # 1
(print "Counter 1 call 2: " (c1))  # 2
(print "Counter 2 call 1: " (c2))  # 101
(print "Counter 1 call 3: " (c1))  # 3

# Approach for objects with multiple operations:
# Create a multi-operation object using dispatch pattern
(def (make-bank-account initial-balance)
  # Private state
  (= balance initial-balance)
  
  # Create a dispatcher function that handles operations
  (def (dispatch op)
    # Check which operation was requested
    (if (== op "balance")
      # Return current balance
      balance
      
      (if (== op "deposit")
        # Return a deposit function
        (lambda (amount)
          (= balance (+ balance amount))
          balance)
        
        (if (== op "withdraw")
          # Return a withdraw function
          (lambda (amount)
            (if (>= balance amount)
              (begin
                (= balance (- balance amount))
                balance)
              "Insufficient funds"))
          
          # Unknown operation
          "Unknown operation"))))
  
  # Return the dispatch function
  dispatch)

# Create two accounts with different initial balances
(= acct1 (make-bank-account 100))
(= acct2 (make-bank-account 500))

# Test basic balance operations
(print "Account 1 initial balance: " (acct1 "balance"))  # 100
(print "Account 2 initial balance: " (acct2 "balance"))  # 500

# Use deposit function
(= deposit1 (acct1 "deposit"))
(print "Deposit 50 to account 1: " (deposit1 50))  # 150
(print "Account 1 after deposit: " (acct1 "balance"))  # 150

# Use withdraw function
(= withdraw2 (acct2 "withdraw"))
(print "Withdraw 200 from account 2: " (withdraw2 200))  # 300
(print "Account 2 after withdrawal: " (acct2 "balance"))  # 300

# Try to withdraw too much
(print "Withdraw 1000 from account 2: " (withdraw2 1000))  # Insufficient funds

# Make deposits to both accounts
(print "Another deposit to account 1: " (deposit1 200))  # 350
(= deposit2 (acct2 "deposit"))
(print "Deposit to account 2: " (deposit2 100))  # 400

# Check final balances (should be independent)
(print "Account 1 final balance: " (acct1 "balance"))  # 350
(print "Account 2 final balance: " (acct2 "balance"))  # 400