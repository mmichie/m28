# Higher-Order Functions in M28
# Functions that take or return other functions

# Function that takes a function as argument
(def apply_twice (f x)
  (f (f x)))

(def double (x)
  (* x 2))

(print "Apply double twice to 5:" (apply_twice double 5))  # 20

# Function composition
(def compose (f g)
  (lambda (x) (f (g x))))

(def add_one (x)
  (+ x 1))

(def square (x)
  (* x x))

(= square_then_add_one (compose add_one square))
(= add_one_then_square (compose square add_one))

(print "\nFunction composition:")
(print "square(5) then add 1:" (square_then_add_one 5))  # 26
(print "add 1 to 5 then square:" (add_one_then_square 5))  # 36

# Partial application - simplified example
(def make_adder (n)
  (lambda (x) (+ n x)))

(def make_multiplier (n)
  (lambda (x) (* n x)))

(= add_10 (make_adder 10))
(= multiply_by_3 (make_multiplier 3))

(print "\nPartial application:")
(print "add_10(5):" (add_10 5))  # 15
(print "multiply_by_3(7):" (multiply_by_3 7))  # 21

# Custom map implementation
(def my_map (f lst)
  (if (== (len lst) 0)
      []
      (+ [(f lst[0])] (my_map f lst[1:]))))

(print "\nCustom map:")
(print (my_map (lambda (x) (* x x)) [1, 2, 3, 4]))

# Custom filter implementation
(def my_filter (pred lst)
  (if (== (len lst) 0)
      []
      (if (pred lst[0])
          (+ [lst[0]] (my_filter pred lst[1:]))
          (my_filter pred lst[1:]))))

(print "\nCustom filter:")
(print (my_filter (lambda (x) (> x 2)) [1, 2, 3, 4, 5]))

# Function decorator pattern
(def with_logging (f)
  (lambda (a b)
    (print "Calling function with args: (" a ", " b ")")
    (= result (f a b))
    (print "Result: " result)
    result))

(def multiply (a b)
  (* a b))

(= logged_multiply (with_logging multiply))

(print "\nFunction with logging:")
(logged_multiply 5 3)

# Memoization example (simplified for single argument)
(def memoize (f)
  (= cache {})
  (lambda (n)
    (if (in n cache)
        (do
          (print "Cache hit for " n)
          cache[n])
        (do
          (print "Computing for " n)
          (= result (f n))
          (= cache[n] result)
          result))))

(def slow_fibonacci (n)
  (if (<= n 1)
      n
      (+ (slow_fibonacci (- n 1))
         (slow_fibonacci (- n 2)))))

(= fast_fibonacci (memoize slow_fibonacci))

(print "\nMemoized Fibonacci:")
(print "fib(10):" (fast_fibonacci 10))
(print "fib(10) again:" (fast_fibonacci 10))  # From cache

# Pipeline function
(def pipeline (*funcs)
  (lambda (x)
    (reduce (lambda (acc f) (f acc)) funcs x)))

(= process (pipeline
  (lambda (x) (* x 2))      # Double
  (lambda (x) (+ x 10))     # Add 10
  (lambda (x) (/ x 3))))    # Divide by 3

(print "\nPipeline example:")
(print "Process 5:" (process 5))  # ((5 * 2) + 10) / 3 = 6.67

# Predicate combinators
(def both (pred1 pred2)
  (lambda (x) (and (pred1 x) (pred2 x))))

(def either (pred1 pred2)
  (lambda (x) (or (pred1 x) (pred2 x))))

(= is_positive (lambda (x) (> x 0)))
(= is_even (lambda (x) (== (% x 2) 0)))

(= positive_and_even (both is_positive is_even))
(= positive_or_even (either is_positive is_even))

(print "\nPredicate combinators:")
(= test_values [-2, -1, 0, 1, 2, 3, 4])
(print "Positive AND even:" (filter positive_and_even test_values))
(print "Positive OR even:" (filter positive_or_even test_values))