# Closure Tutorial for M28
# A comprehensive guide to understanding and using closures

#####################################################
# 1. What is a Closure? - Simple Example
#####################################################

(print "\n=== 1. What is a Closure? ===")
(print "A closure is a function that 'remembers' its creation environment")

# A function that creates a simple greeter closure
(def (make-greeter name)
  # This inner function "closes over" the name variable
  (lambda (message)
    (+ message ", " name "!")))

# Create two different greeters
(= alice-greeter (make-greeter "Alice"))
(= bob-greeter (make-greeter "Bob"))

# Test the greeters
(print "Alice greeting: " (alice-greeter "Hello"))
(print "Bob greeting: " (bob-greeter "Hi there"))
(print "Alice greeting again: " (alice-greeter "Good morning"))

(print "Note: Each closure remembers the value of 'name' when it was created")

#####################################################
# 2. Closures with State - Counter Example
#####################################################

(print "\n=== 2. Closures with State ===")
(print "Closures can maintain and update state between calls")

# A counter factory that creates counter functions
(def (make-counter)
  # Private state for each counter
  (= count 0)
  
  # Function that increments and returns the count
  # This lambda closes over the 'count' variable
  (lambda ()
    (= count (+ count 1))
    count))

# Create two counter instances
(= counter1 (make-counter))
(= counter2 (make-counter))

# Test the counters
(print "Counter 1 first call: " (counter1))
(print "Counter 1 second call: " (counter1))
(print "Counter 2 first call: " (counter2))
(print "Counter 1 third call: " (counter1))

(print "Note: Each counter maintains its own independent state")

#####################################################
# 3. Closures with Multiple Operations
#####################################################

(print "\n=== 3. Closures with Multiple Operations ===")
(print "Using dispatch functions to implement multiple operations")

# A calculator factory
(def (make-calculator)
  # Private state
  (= memory 0)
  
  # Return a dispatch function that handles different operations
  (lambda (op value)
    (if (= op "add")
        (begin
          (= memory (+ memory value))
          memory)
        (if (= op "subtract")
            (begin
              (= memory (- memory value))
              memory)
            (if (= op "multiply")
                (begin
                  (= memory (* memory value))
                  memory)
                (if (= op "divide")
                    (begin
                      (= memory (/ memory value))
                      memory)
                    (if (= op "clear")
                        (begin
                          (= memory 0)
                          memory)
                        (if (= op "get")
                            memory
                            (error (+ "Unknown operation: " op))))))))))

# Create calculators
(= calc1 (make-calculator))
(= calc2 (make-calculator))

# Test calculator 1
(print "Calculator 1 - Add 5: " (calc1 "add" 5))
(print "Calculator 1 - Add 10: " (calc1 "add" 10))
(print "Calculator 1 - Subtract 3: " (calc1 "subtract" 3))
(print "Calculator 1 - Get value: " (calc1 "get" 0))

# Test calculator 2
(print "Calculator 2 - Add 100: " (calc2 "add" 100))
(print "Calculator 2 - Multiply by 2: " (calc2 "multiply" 2))
(print "Calculator 2 - Get value: " (calc2 "get" 0))

# Return to calculator 1
(print "Calculator 1 - Get value again: " (calc1 "get" 0))

#####################################################
# 4. Objects Using Closures - Dictionary of Methods
#####################################################

(print "\n=== 4. Objects Using Closures ===")
(print "Implementing an object-like structure using closures and dictionaries")

# A person factory
(def (make-person name age)
  # Private person state
  (= birthdays 0)
  (= friends [])
  
  # Method to have a birthday
  (def (celebrate-birthday)
    (= birthdays (+ birthdays 1))
    (= age (+ age 1))
    (+ name " is now " (str age) " years old!"))
  
  # Method to add a friend
  (def (add-friend friend)
    (= friends (+ friends [friend]))
    (+ name " is now friends with " friend "!"))
  
  # Method to list all friends
  (def (list-friends)
    (if (= (len friends) 0)
      (+ name " has no friends yet.")
      (+ name "'s friends: " (str friends))))
  
  # Method to get person info
  (def (get-info)
    (dict 
      "name" name 
      "age" age 
      "birthdays" birthdays 
      "friends_count" (len friends)))
  
  # Return a dictionary with methods
  (dict
    "birthday" celebrate-birthday
    "add-friend" add-friend
    "friends" list-friends
    "info" get-info))

# Create a few people
(= alice (make-person "Alice" 30))
(= bob (make-person "Bob" 25))

# Test methods
(print "Initial info:")
(print "Alice: " ((get alice "info")))
(print "Bob: " ((get bob "info")))

# Have some birthdays
(print ((get alice "birthday")))
(print ((get bob "birthday")))

# Add some friends
(print ((get alice "add-friend") "Bob"))
(print ((get bob "add-friend") "Alice"))

# List friends
(print ((get alice "friends")))
(print ((get bob "friends")))

# Check updated info
(print "Updated info:")
(print "Alice: " ((get alice "info")))
(print "Bob: " ((get bob "info")))

#####################################################
# 5. Nested Closures - Creating Complex Behavior
#####################################################

(print "\n=== 5. Nested Closures ===")
(print "Creating closures that return closures for complex behavior")

# A function that creates adders
(def (make-adder base)
  # Returns a function that adds to the base
  (lambda (x)
    (+ base x)))

# Create two adders with different bases
(= add5 (make-adder 5))
(= add10 (make-adder 10))

# Test the adders
(print "add5(3): " (add5 3))
(print "add5(7): " (add5 7))
(print "add10(3): " (add10 3))

# Now a nested closure example - a function factory factory
(def (make-operation-factory op)
  # Returns a function that creates a function to perform the operation
  (lambda (n)
    (if (= op "multiply")
        (lambda (x) (* n x))
        (if (= op "power")
            (lambda (x) (^ x n))
            (if (= op "add")
                (lambda (x) (+ x n))
                (error "Unsupported operation"))))))

# Create operation factories
(= multiply-factory (make-operation-factory "multiply"))
(= power-factory (make-operation-factory "power"))
(= add-factory (make-operation-factory "add"))

# Create specific operation functions
(= multiply-by-2 (multiply-factory 2))
(= square (power-factory 2))
(= cube (power-factory 3))
(= add-3 (add-factory 3))

# Test the operations
(print "multiply-by-2(5): " (multiply-by-2 5))
(print "square(4): " (square 4))
(print "cube(3): " (cube 3))
(print "add-3(7): " (add-3 7))

(print "\n=== Closure Tutorial Complete ===")