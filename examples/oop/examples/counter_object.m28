# Counter Object Example
# A clean, reusable implementation of a counter with encapsulated state

# This example demonstrates:
# 1. Private, encapsulated state using closures
# 2. Method dispatch using a dictionary
# 3. Clean interface for interacting with the object

# Create a counter factory function that produces counter objects
(def (make-counter initial-count)
  # Private state (encapsulated within the closure)
  (= count (or initial-count 0)) # Default to 0 if no initial count given
  (= operations 0)               # Track number of operations performed
  
  # Method to get current count
  (def (get-count)
    count)
  
  # Method to increment by optional amount (default 1)
  (def (increment amount)
    (= amount (or amount 1))
    (= count (+ count amount))
    (= operations (+ operations 1))
    count)
  
  # Method to decrement by optional amount (default 1)
  (def (decrement amount)
    (= amount (or amount 1))
    (= count (- count amount))
    (= operations (+ operations 1))
    count)
  
  # Method to reset to zero or optional value
  (def (reset new-value)
    (= new-value (or new-value 0))
    (= count new-value)
    (= operations (+ operations 1))
    count)
  
  # Method to get number of operations performed
  (def (get-operations)
    operations)
  
  # Return a dictionary of methods (the actual counter object)
  (dict 
    "count" get-count
    "increment" increment
    "decrement" decrement
    "reset" reset
    "operations" get-operations))

# Create counters with different initial values
(= counter1 (make-counter 0))
(= counter2 (make-counter 10))

# Test counter1
(print "\n--- COUNTER 1 TESTS ---")
(print "Initial count: " ((get counter1 "count")))
(print "After increment: " ((get counter1 "increment")))
(print "After increment by 5: " ((get counter1 "increment") 5))
(print "Operations performed: " ((get counter1 "operations")))
(print "After decrement: " ((get counter1 "decrement")))
(print "After reset: " ((get counter1 "reset")))
(print "Operations performed: " ((get counter1 "operations")))

# Test counter2
(print "\n--- COUNTER 2 TESTS ---")
(print "Initial count: " ((get counter2 "count")))
(print "After decrement: " ((get counter2 "decrement")))
(print "After decrement by 3: " ((get counter2 "decrement") 3))
(print "Operations performed: " ((get counter2 "operations")))
(print "After reset to 100: " ((get counter2 "reset") 100))
(print "Operations performed: " ((get counter2 "operations")))

# Verify counter1 is unaffected by counter2 operations
(print "\n--- VERIFY SEPARATE STATE ---")
(print "Counter 1 count: " ((get counter1 "count")))
(print "Counter 1 operations: " ((get counter1 "operations")))

# Advanced usage example: creating a specialized counter
(def (make-bounded-counter min max)
  # Create a basic counter
  (= counter (make-counter min))
  
  # Override the increment method to respect max bound
  (def (bounded-increment amount)
    (= amount (or amount 1))
    (= current ((get counter "count")))
    (if (>= (+ current amount) max)
      (begin
        ((get counter "reset") max)
        max)
      ((get counter "increment") amount)))
  
  # Override the decrement method to respect min bound
  (def (bounded-decrement amount)
    (= amount (or amount 1))
    (= current ((get counter "count")))
    (if (<= (- current amount) min)
      (begin
        ((get counter "reset") min)
        min)
      ((get counter "decrement") amount)))
  
  # Create new dictionary with overridden methods
  (= bounded (dict))
  
  # Copy original methods
  (for key (dict.keys counter)
    (= bounded (dict.set bounded key (get counter key))))
  
  # Override specific methods
  (= bounded (dict.set bounded "increment" bounded-increment))
  (= bounded (dict.set bounded "decrement" bounded-decrement))
  
  # Return the bounded counter
  bounded)

# Test bounded counter
(= bounded (make-bounded-counter 0 10))
(print "\n--- BOUNDED COUNTER TESTS ---")
(print "Initial value: " ((get bounded "count")))
(print "Increment by 5: " ((get bounded "increment") 5))
(print "Increment by 10: " ((get bounded "increment") 10)) # Should stop at 10
(print "Decrement by 15: " ((get bounded "decrement") 15)) # Should stop at 0