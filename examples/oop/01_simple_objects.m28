# 01_simple_objects.m28
# Progressive OOP Example 1: Basic Object Creation and Access

# This file demonstrates the simplest forms of object-oriented programming in M28.
# We'll show three fundamental approaches to creating objects:
# 1. Single function objects
# 2. Dispatch function objects
# 3. Dictionary-based objects

##############################################################
# APPROACH 1: SINGLE FUNCTION OBJECTS
##############################################################
# The simplest form of an "object" is a function that closes over state

# Create a basic counter object
(def (make-counter)
  # Private state (encapsulated within the closure)
  (= count 0)
  
  # Return a function that both increments and returns count
  # This function serves as both the object and its only method
  (lambda ()
    (= count (+ count 1))
    count))

# Create two independent counter instances
(= counter1 (make-counter))
(= counter2 (make-counter))

# Test counters (each maintains separate state)
(print "\n--- SIMPLE COUNTER TESTS ---")
(print "Counter 1 first call: " (counter1))   # 1
(print "Counter 1 second call: " (counter1))  # 2
(print "Counter 2 first call: " (counter2))   # 1 
(print "Counter 1 third call: " (counter1))   # 3

# This works because:
# 1. Each call to make-counter creates a new environment (lexical scope)
# 2. The lambda captures this environment and the count variable
# 3. Subsequent calls to the lambda update and return count

##############################################################
# APPROACH 2: DISPATCH FUNCTION OBJECTS
##############################################################
# For objects that need multiple operations, we can use a dispatch pattern

# Create a person factory
(def (make-person name age)
  # Private state
  (= person-name name)
  (= person-age age)
  
  # Return a dispatch function that handles different operations
  (lambda (op)
    (if (== op "name")
      person-name
      (if (== op "age")
        person-age
        (if (== op "birthday")
          (begin
            (= person-age (+ person-age 1))
            (+ person-name " is now " (str person-age) " years old!"))
          "unknown")))))

# Create two people
(= alice (make-person "Alice" 30))
(= bob (make-person "Bob" 25))

# Test operations
(print "\n--- DISPATCH FUNCTION OBJECT TESTS ---")
(print "Alice's name: " (alice "name"))
(print "Alice's age: " (alice "age"))
(print "Bob's name: " (bob "name"))
(print "Bob's age: " (bob "age"))

# Test object methods with side effects
(print (alice "birthday"))
(print "Alice's age after birthday: " (alice "age"))

# Verify each object has independent state
(print (bob "birthday"))
(print "Bob's age after birthday: " (bob "age"))

##############################################################
# APPROACH 3: DICTIONARY-BASED OBJECTS
##############################################################
# Using dictionaries to store methods provides a more explicit structure

# Create a simple object with method
(def (make-greeter name)
  # Create the methods
  (def (say-hello)
    (+ "Hello, I am " name "!"))
    
  (def (say-goodbye)
    (+ "Goodbye from " name "!"))
  
  # Return a dictionary containing the methods
  (dict "greet" say-hello
        "goodbye" say-goodbye))

# Create an object
(= greeter (make-greeter "World"))

# Get methods from the object and call them
(print "\n--- DICTIONARY-BASED OBJECT TESTS ---")
(= greet-fn (get greeter "greet"))
(print "Result: " (greet-fn))

(= goodbye-fn (get greeter "goodbye"))
(print "Result: " (goodbye-fn))

# Create a data container object
(def (make-data-container initial-data)
  # Private state
  (= data initial-data)
  
  # Define methods
  (def (get-data key)
    (get data key))
    
  (def (set-data key value)
    (= data (dict.set data key value))
    value)
    
  (def (list-keys)
    (dict.keys data))
  
  # Return object with methods
  (dict "get" get-data
        "set" set-data
        "keys" list-keys))

# Test data container
(= container (make-data-container (dict "a" 1 "b" 2)))
(print "\n--- DATA CONTAINER TESTS ---")
(print "Initial keys: " ((get container "keys")))
(print "Value of 'a': " ((get container "get") "a"))
(print "Setting 'c' to 3: " ((get container "set") "c" 3))
(print "Updated keys: " ((get container "keys")))

# Benefits of dictionary-based objects:
# 1. More explicit structure - methods are clearly defined
# 2. Easier to add/remove methods dynamically
# 3. More familiar to users of other OOP languages
# 4. Enables more complex patterns like inheritance