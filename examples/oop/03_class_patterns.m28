# 03_class_patterns.m28
# Progressive OOP Example 3: Class-like Patterns

# This file demonstrates how to create class-like structures in M28.
# We'll explore two main patterns:
# 1. Factory functions that simulate classes
# 2. The class syntax introduced in M28

##############################################################
# APPROACH 1: CLASS FACTORY FUNCTIONS
##############################################################
# Using factory functions to simulate classes

# Define a Counter class factory
(def (make-counter initial-count)
  # Private state (instance variables)
  (= count initial-count)
  
  # Define methods
  (def (get-count)
    count)
  
  (def (increment)
    (= count (+ count 1))
    count)
    
  (def (decrement)
    (= count (- count 1))
    count)
    
  (def (reset)
    (= count initial-count)
    count)
  
  # Return dictionary with methods (the instance)
  (= counter-obj (dict))
  (= counter-obj (dict 
    "get-count" get-count
    "increment" increment
    "decrement" decrement
    "reset" reset))
  
  counter-obj)

# Create a counter instance
(= counter1 (make-counter 0))
(= counter2 (make-counter 10))

# Call its methods
(print "\n--- FACTORY FUNCTION CLASS TESTS ---")
(print "Counter1 initial count:" ((get counter1 "get-count")))
(print "Counter1 after increment:" ((get counter1 "increment")))
(print "Counter1 after another increment:" ((get counter1 "increment")))
(print "Counter2 initial count:" ((get counter2 "get-count")))
(print "Counter2 after decrement:" ((get counter2 "decrement")))

# Test reset
(print "Counter1 after reset:" ((get counter1 "reset")))

# Benefits of factory functions:
# 1. Clear separation between instantiation and the class definition
# 2. Easy to understand, using only basic language features
# 3. Private state is naturally maintained through closures

##############################################################
# APPROACH 2: PERSON CLASS WITH FACTORY FUNCTION
##############################################################
# A more complex example with multiple methods and state

(def (make-person name age)
  # Private state
  (= person-name name)
  (= person-age age)
  (= friends [])
  
  # Dictionary for methods
  (= methods (dict))
  
  # Define methods
  (def (get-name)
    person-name)
    
  (def (get-age)
    person-age)
    
  (def (have-birthday)
    (= person-age (+ person-age 1))
    (+ person-name " is now " (str person-age) " years old!"))
    
  (def (add-friend friend-name)
    (= friends (+ friends [friend-name]))
    (+ "Added " friend-name " as a friend"))
    
  (def (list-friends)
    (if (== (len friends) 0)
      "No friends yet"
      (+ person-name "'s friends: " (str friends))))
  
  # Populate methods dictionary
  (= methods (dict
    "name" get-name
    "age" get-age
    "birthday" have-birthday
    "add-friend" add-friend
    "friends" list-friends))
  
  # Return the methods dictionary
  methods)

# Create person instances
(= alice (make-person "Alice" 30))
(= bob (make-person "Bob" 25))

# Test methods
(print "\n--- COMPLEX FACTORY CLASS TESTS ---")
(print "Alice's name:" ((get alice "name")))
(print "Alice's age:" ((get alice "age")))
(print "Alice's birthday:" ((get alice "birthday")))
(print "Alice's friends initially:" ((get alice "friends")))
(print ((get alice "add-friend") "Bob"))
(print ((get bob "add-friend") "Alice"))
(print "Alice's friends now:" ((get alice "friends")))
(print "Bob's friends now:" ((get bob "friends")))

##############################################################
# APPROACH 3: USING THE CLASS SYNTAX
##############################################################
# M28 provides a class syntax that simplifies object creation

# Define a Person class with the class syntax
(class Person
  # Instance variables with default values
  (= name "Anonymous")
  (= age 0)
  (= friends [])
  
  # Constructor method
  (def (init self new-name new-age)
    # In the class syntax, we must use dict.set instead of direct assignment
    (dict.set self "name" new-name)
    (dict.set self "age" new-age))
  
  # Regular methods
  (def (greet self)
    (+ "Hello, my name is " (dict.get self "name")))
    
  (def (birthday self)
    (dict.set self "age" (+ (dict.get self "age") 1))
    (+ (dict.get self "name") " is now " (str (dict.get self "age")) " years old!"))
    
  (def (add-friend self friend-name)
    (dict.set self "friends" (+ (dict.get self "friends") [friend-name]))
    (+ "Added " friend-name " as a friend"))
    
  (def (list-friends self)
    (= friend-list (dict.get self "friends"))
    (if (== (len friend-list) 0)
      "No friends yet"
      (+ (dict.get self "name") "'s friends: " (str friend-list)))))

# Create instances using the class name
(= carol (Person "Carol" 35))
(= dave (Person "Dave" 40))

# Get methods from the dictionary and call them with the instance
(print "\n--- CLASS SYNTAX TESTS ---")
(print ((dict.get carol "greet") carol))
(print ((dict.get dave "greet") dave))

# Update state with methods
(print ((dict.get carol "birthday") carol))
(print ((dict.get carol "birthday") carol))
(print ((dict.get dave "birthday") dave))

# Test friend methods
(print ((dict.get carol "add-friend") carol "Dave"))
(print ((dict.get dave "add-friend") dave "Carol"))
(print ((dict.get carol "list-friends") carol))
(print ((dict.get dave "list-friends") dave))

# Benefits of the class syntax:
# 1. More concise and recognizable as object-oriented code
# 2. Consistent structure for defining classes
# 3. Explicit self parameter makes method access clearer
# 4. Enables inheritance and other advanced OOP patterns

##############################################################
# APPROACH 4: COMBINING FACTORY AND CLASS PATTERNS
##############################################################
# We can create a class-like factory with a more elegant interface

# Create a class-like factory function
(def (Counter initial-count)
  # Local state
  (= count initial-count)
  (= history [])
  
  # Methods
  (def (get-count self)
    count)
    
  (def (increment self)
    (= count (+ count 1))
    (= history (+ history ["increment"]))
    count)
    
  (def (decrement self)
    (= count (- count 1))
    (= history (+ history ["decrement"]))
    count)
    
  (def (get-history self)
    history)
  
  # Method registry
  (= methods (dict
    "count" get-count
    "increment" increment
    "decrement" decrement
    "history" get-history))
  
  # Self-referential dispatcher
  (= self nil) # Placeholder
  (= dispatcher 
    (lambda (method-name . args)
      (= method (get methods method-name))
      (if method
        (apply method (+ [dispatcher] args))
        "Unknown method")))
  
  # Return the dispatcher
  dispatcher)

# Rename to match class naming convention
# This allows us to use it like a class

# Create instances
(= counter3 (Counter 5))
(= counter4 (Counter 20))

# Test methods
(print "\n--- CLASS-LIKE FACTORY TESTS ---")
(print "Counter3 initial count:" (counter3 "count"))
(print "Counter3 after increment:" (counter3 "increment"))
(print "Counter3 after another increment:" (counter3 "increment"))
(print "Counter4 initial count:" (counter4 "count"))
(print "Counter4 after decrement:" (counter4 "decrement"))
(print "Counter3 history:" (counter3 "history"))

# Comparison of approaches:
# 1. Factory functions are simpler but more verbose
# 2. Class syntax is more concise but has specific requirements
# 3. Class-like factories combine clarity with flexibility
# 4. Choose based on your specific needs and preferences