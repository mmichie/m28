# Test merge operations (merge, deep-merge, merge-with)

(print "Testing Merge Operations")
(print "=" 70)

# =============================================================================
# Test 1: merge basic functionality
# =============================================================================
(print "\n1. Testing merge basic functionality")
(print "-" 70)

(= dict1 {"a": 1 "b": 2})
(= dict2 {"c": 3 "d": 4})

(= result (merge dict1 dict2))
(print (+ "Merged: " (str result)))
(assert (== (len result) 4) "merge combines keys")
(assert (== (get-item result "a") 1) "merge preserves dict1 keys")
(assert (== (get-item result "c") 3) "merge adds dict2 keys")

# Verify original unchanged
(assert (== (len dict1) 2) "merge doesn't modify dict1")
(assert (== (len dict2) 2) "merge doesn't modify dict2")

(print "✓ merge basic functionality works")

# =============================================================================
# Test 2: merge with overlapping keys (later wins)
# =============================================================================
(print "\n2. Testing merge with overlapping keys")
(print "-" 70)

(= base {"a": 1 "b": 2 "c": 3})
(= override {"b": 20 "c": 30 "d": 40})

(= result (merge base override))
(print (+ "Merged with overlap: " (str result)))
(assert (== (get-item result "a") 1) "merge keeps non-overlapping keys")
(assert (== (get-item result "b") 20) "merge: later value wins")
(assert (== (get-item result "c") 30) "merge: later value wins for all conflicts")
(assert (== (get-item result "d") 40) "merge adds new keys")

(print "✓ merge with overlapping keys works (later wins)")

# =============================================================================
# Test 3: merge multiple dicts
# =============================================================================
(print "\n3. Testing merge with multiple dicts")
(print "-" 70)

(= dict1 {"a": 1})
(= dict2 {"b": 2})
(= dict3 {"c": 3})
(= dict4 {"a": 10})

(= result (merge dict1 dict2 dict3 dict4))
(print (+ "Merged 4 dicts: " (str result)))
(assert (== (len result) 3) "merge handles multiple dicts")
(assert (== (get-item result "a") 10) "merge: rightmost value wins")
(assert (== (get-item result "b") 2) "merge preserves all unique keys")
(assert (== (get-item result "c") 3) "merge preserves all unique keys")

(print "✓ merge with multiple dicts works")

# =============================================================================
# Test 4: merge edge cases
# =============================================================================
(print "\n4. Testing merge edge cases")
(print "-" 70)

# Empty dict
(= result1 (merge))
(assert (== (len result1) 0) "merge with no args returns empty dict")

# Single dict (returns copy)
(= single {"x": 1})
(= result2 (merge single))
(assert (== (len result2) 1) "merge with one dict returns copy")
(assert (== (get-item result2 "x") 1) "merge preserves single dict values")

# Merge with empty
(= result3 (merge {"a": 1} {}))
(assert (== (len result3) 1) "merge with empty dict works")

(= result4 (merge {} {"b": 2}))
(assert (== (len result4) 1) "merge empty with dict works")

(print "✓ merge edge cases work")

# =============================================================================
# Test 5: deep-merge basic functionality
# =============================================================================
(print "\n5. Testing deep-merge basic functionality")
(print "-" 70)

(= user1 {"name": "Alice" "settings": {"theme": "dark" "lang": "en"}})
(= user2 {"age": 30 "settings": {"notifications": true}})

(= result (deep-merge user1 user2))
(print (+ "Deep merged: " (str result)))
(assert (== (get-item result "name") "Alice") "deep-merge preserves top-level keys")
(assert (== (get-item result "age") 30) "deep-merge adds new top-level keys")

(= settings (get-item result "settings"))
(assert (== (get-item settings "theme") "dark") "deep-merge preserves nested keys from dict1")
(assert (== (get-item settings "lang") "en") "deep-merge preserves nested keys")
(assert (== (get-item settings "notifications") true) "deep-merge adds nested keys from dict2")

# Verify original unchanged
(= orig-settings (get-item user1 "settings"))
(assert (== (len orig-settings) 2) "deep-merge doesn't modify original")
(assert (not (has-path? user1 "age")) "deep-merge doesn't add to original")

(print "✓ deep-merge basic functionality works")

# =============================================================================
# Test 6: deep-merge with nested dicts (3 levels)
# =============================================================================
(print "\n6. Testing deep-merge with deeply nested structures")
(print "-" 70)

(= config1 {
    "database": {"host": "localhost" "port": 5432}
    "cache": {"redis": {"host": "localhost" "port": 6379}}
})

(= config2 {
    "database": {"name": "mydb"}
    "cache": {"redis": {"ttl": 3600} "enabled": true}
})

(= result (deep-merge config1 config2))
(print (+ "Deep merged config: " (str result)))

# Check database merge
(= db (get-item result "database"))
(assert (== (get-item db "host") "localhost") "deep-merge preserves nested values")
(assert (== (get-item db "port") 5432) "deep-merge preserves nested values")
(assert (== (get-item db "name") "mydb") "deep-merge adds nested values")

# Check cache merge (3 levels deep)
(= redis (get-path result "cache.redis"))
(assert (== (get-item redis "host") "localhost") "deep-merge works 3 levels deep")
(assert (== (get-item redis "port") 6379) "deep-merge preserves deep values")
(assert (== (get-item redis "ttl") 3600) "deep-merge adds deep values")

(= cache (get-item result "cache"))
(assert (== (get-item cache "enabled") true) "deep-merge handles mixed nesting")

(print "✓ deep-merge with deeply nested structures works")

# =============================================================================
# Test 7: deep-merge with type mismatches (later wins)
# =============================================================================
(print "\n7. Testing deep-merge with type mismatches")
(print "-" 70)

(= dict1 {"a": {"b": 1}})
(= dict2 {"a": "string"})

(= result (deep-merge dict1 dict2))
(print (+ "Type mismatch result: " (str result)))
(assert (== (get-item result "a") "string") "deep-merge: later value wins on type mismatch")

# Dict replaced by list
(= dict3 {"x": {"nested": true}})
(= dict4 {"x": [1 2 3]})
(= result2 (deep-merge dict3 dict4))
(assert (== (type (get-item result2 "x")) "list") "deep-merge: list replaces dict")

# List replaced by dict
(= dict5 {"y": [1 2 3]})
(= dict6 {"y": {"new": "value"}})
(= result3 (deep-merge dict5 dict6))
(assert (== (type (get-item result3 "y")) "dict") "deep-merge: dict replaces list")

(print "✓ deep-merge with type mismatches works (later wins)")

# =============================================================================
# Test 8: deep-merge with lists (later wins, not concatenated)
# =============================================================================
(print "\n8. Testing deep-merge with lists")
(print "-" 70)

(= dict1 {"tags": ["python" "lisp"]})
(= dict2 {"tags": ["golang"]})

(= result (deep-merge dict1 dict2))
(print (+ "Lists merged: " (str result)))
(= tags (get-item result "tags"))
(assert (== (len tags) 1) "deep-merge: lists are replaced, not concatenated")
(assert (== (get-item tags 0) "golang") "deep-merge: later list wins")

(print "✓ deep-merge with lists works (later wins)")

# =============================================================================
# Test 9: deep-merge multiple dicts
# =============================================================================
(print "\n9. Testing deep-merge with multiple dicts")
(print "-" 70)

(= base {"a": {"x": 1}})
(= layer1 {"a": {"y": 2}})
(= layer2 {"a": {"z": 3}})
(= layer3 {"a": {"x": 10}})

(= result (deep-merge base layer1 layer2 layer3))
(print (+ "Multi-layer merge: " (str result)))

(= inner (get-item result "a"))
(assert (== (get-item inner "x") 10) "deep-merge: multiple dicts, rightmost wins")
(assert (== (get-item inner "y") 2) "deep-merge: multiple dicts preserve all keys")
(assert (== (get-item inner "z") 3) "deep-merge: multiple dicts preserve all keys")

(print "✓ deep-merge with multiple dicts works")

# =============================================================================
# Test 10: merge-with custom function
# =============================================================================
(print "\n10. Testing merge-with with custom functions")
(print "-" 70)

(= dict1 {"a": 1 "b": 2})
(= dict2 {"a": 10 "c": 3})

# Add values on conflict
(= result (merge-with + dict1 dict2))
(print (+ "Merged with +: " (str result)))
(assert (== (get-item result "a") 11) "merge-with applies function to conflicts")
(assert (== (get-item result "b") 2) "merge-with preserves non-conflicting keys")
(assert (== (get-item result "c") 3) "merge-with adds new keys")

# Multiply values on conflict
(= result2 (merge-with (lambda (a b) (* a b)) dict1 dict2))
(print (+ "Merged with *: " (str result2)))
(assert (== (get-item result2 "a") 10) "merge-with: different function works")

(print "✓ merge-with with custom functions works")

# =============================================================================
# Test 11: merge-with with lambda
# =============================================================================
(print "\n11. Testing merge-with with lambda functions")
(print "-" 70)

(= dict1 {"x": [1 2]})
(= dict2 {"x": [3 4]})

# Concatenate lists
(= result (merge-with (lambda (v1 v2) (+ v1 v2)) dict1 dict2))
(print (+ "Lists concatenated: " (str result)))
(= merged-list (get-item result "x"))
(assert (== (len merged-list) 4) "merge-with can concatenate lists")
(assert (== (get-item merged-list 0) 1) "merge-with preserves order")
(assert (== (get-item merged-list 2) 3) "merge-with appends second list")

# Take max value
(= nums1 {"score": 85 "level": 5})
(= nums2 {"score": 92 "health": 100})
(= result2 (merge-with (lambda (v1 v2) (if (> v1 v2) v1 v2)) nums1 nums2))
(print (+ "Max values: " (str result2)))
(assert (== (get-item result2 "score") 92) "merge-with can take max")
(assert (== (get-item result2 "level") 5) "merge-with preserves unique keys")
(assert (== (get-item result2 "health") 100) "merge-with adds new keys")

(print "✓ merge-with with lambda functions works")

# =============================================================================
# Test 12: merge-with multiple dicts
# =============================================================================
(print "\n12. Testing merge-with with multiple dicts")
(print "-" 70)

(= dict1 {"a": 1})
(= dict2 {"a": 2})
(= dict3 {"a": 3})
(= dict4 {"a": 4})

(= result (merge-with + dict1 dict2 dict3 dict4))
(print (+ "Sum of all values: " (str result)))
(assert (== (get-item result "a") 10) "merge-with accumulates across multiple dicts")

(print "✓ merge-with with multiple dicts works")

# =============================================================================
# Test 13: Composing merge operations with path-ops and dict-ops
# =============================================================================
(print "\n13. Testing composition with other operations")
(print "-" 70)

(= base-config {
    "database": {"host": "localhost" "port": 5432}
    "cache": {"ttl": 3600}
    "features": {"new_ui": false "beta": true}
})

(= user-config {
    "database": {"name": "mydb"}
    "cache": {"ttl": 7200 "enabled": true}
    "features": {"new_ui": true}
})

# Deep merge, then select keys, then update a value
(= result (-> base-config
              (deep-merge user-config)
              (select-keys ["database" "cache"])
              (update-path "cache.ttl" (lambda (x) (* x 2)))))

(print (+ "Composed result: " (str result)))
(assert (== (len result) 2) "Composition works")
(assert (== (get-path result "database.name") "mydb") "deep-merge applied")
(assert (== (get-path result "cache.ttl") 14400) "update-path applied after merge")
(assert (not (has-path? result "features")) "select-keys applied")

(print "✓ Composition with other operations works")

# =============================================================================
# Test 14: Practical use case - configuration management
# =============================================================================
(print "\n14. Testing practical configuration management")
(print "-" 70)

(= defaults {
    "server": {"host": "0.0.0.0" "port": 8080 "timeout": 30}
    "database": {"pool_size": 10 "timeout": 5}
    "logging": {"level": "INFO" "format": "json"}
})

(= production {
    "server": {"host": "app.example.com"}
    "database": {"pool_size": 50}
    "logging": {"level": "WARNING"}
})

(= overrides {
    "server": {"debug": false}
    "database": {"timeout": 10}
})

# Layer configurations: defaults -> production -> overrides
(= final-config (deep-merge defaults production overrides))

(print (+ "Final config: " (str final-config)))

# Check layered values
(assert (== (get-path final-config "server.host") "app.example.com") "Production overrides defaults")
(assert (== (get-path final-config "server.port") 8080) "Defaults preserved when not overridden")
(assert (== (get-path final-config "server.timeout") 30) "Defaults preserved")
(assert (== (get-path final-config "server.debug") false) "Overrides applied last")

(assert (== (get-path final-config "database.pool_size") 50) "Production value")
(assert (== (get-path final-config "database.timeout") 10) "Override value")

(assert (== (get-path final-config "logging.level") "WARNING") "Production logging")
(assert (== (get-path final-config "logging.format") "json") "Default format preserved")

(print "✓ Practical configuration management works")

# =============================================================================
# Test 15: Practical use case - accumulating changes
# =============================================================================
(print "\n15. Testing practical use case - accumulating changes")
(print "-" 70)

# Simulate multiple API responses that need to be combined
(= changes [
    {"users": {"alice": {"name": "Alice"}}}
    {"users": {"bob": {"name": "Bob"}}}
    {"users": {"alice": {"age": 30}}}
    {"users": {"bob": {"age": 25}}}
])

# Accumulate all changes with deep-merge using reduce pattern
(= accumulated {})
(for change changes
    (= accumulated (deep-merge accumulated change)))
(print (+ "Accumulated: " (str accumulated)))

(assert (== (get-path accumulated "users.alice.name") "Alice") "Accumulation works")
(assert (== (get-path accumulated "users.alice.age") 30) "Accumulation merges deeply")
(assert (== (get-path accumulated "users.bob.name") "Bob") "Multiple users accumulated")
(assert (== (get-path accumulated "users.bob.age") 25) "All data preserved")

(print "✓ Accumulating changes works")

# =============================================================================
# Test 16: Edge cases and nil handling
# =============================================================================
(print "\n16. Testing edge cases and nil handling")
(print "-" 70)

# Nil values are valid
(= dict1 {"a": 1 "b": nil})
(= dict2 {"b": 2 "c": nil})
(= result (merge dict1 dict2))
(assert (== (get-item result "b") 2) "nil can be overwritten")
(assert (== (get-item result "c") nil) "nil is a valid value")

# Empty nested dicts
(= dict3 {"x": {}})
(= dict4 {"x": {"y": 1}})
(= result2 (deep-merge dict3 dict4))
(assert (== (get-path result2 "x.y") 1) "Empty dict merged with non-empty")

(print "✓ Edge cases and nil handling work")

# =============================================================================
# Summary
# =============================================================================
(print "\n" "=" 70)
(print "✅ All Merge Operations Tests Passed!")
(print "=" 70)

(print "\nImplemented functions:")
(print "  • merge       - Shallow merge, later values win")
(print "  • deep-merge  - Recursive merge of nested dicts")
(print "  • merge-with  - Custom conflict resolution with function")

(print "\nKey features:")
(print "  • Immutable operations (originals unchanged)")
(print "  • Later values win (predictable behavior)")
(print "  • Variadic arguments (merge multiple dicts)")
(print "  • Type mismatch handling (replace, don't error)")
(print "  • Composable with path-ops and dict-ops")

(print "\nDesign principles:")
(print "  • Pythonic: explicit error handling")
(print "  • Simple: predictable later-wins semantics")
(print "  • Practical: safe defaults, useful behavior")
(print "  • Composable: works with threading macros")

(print "\nUse cases:")
(print "  • Configuration management (layer configs)")
(print "  • API response merging")
(print "  • Accumulating changes")
(print "  • Data transformation pipelines")
